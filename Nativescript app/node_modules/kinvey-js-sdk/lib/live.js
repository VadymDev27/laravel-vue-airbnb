"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = __importDefault(require("lodash/isFunction"));
var events_1 = require("events");
var config_1 = require("./config");
var errors_1 = require("./errors");
var STATUS_PREFIX = 'status:';
var UNCLASSIFIED_EVENTS = 'pubNubEventsNotRouted';
function isValidChannelName(channelName) {
    return (typeof channelName === 'string') && channelName !== '';
}
function isValidReceiver(receiver) {
    if (!receiver) {
        return false;
    }
    var onMessage = receiver.onMessage, onError = receiver.onError, onStatus = receiver.onStatus;
    return isFunction_1.default(onMessage) || isFunction_1.default(onError) || isFunction_1.default(onStatus);
}
var Listener = /** @class */ (function (_super) {
    __extends(Listener, _super);
    function Listener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Listener.prototype.message = function (m) {
        this.emit(m.channel, m.message);
    };
    Listener.prototype.status = function (s) {
        var _this = this;
        var _a = s.affectedChannels, affectedChannels = _a === void 0 ? [] : _a, _b = s.affectedChannelGroups, affectedChannelGroups = _b === void 0 ? [] : _b;
        var allChannels = affectedChannels.concat(affectedChannelGroups);
        var data = {
            error: s.error,
            category: s.category,
            operation: s.operation
        };
        if (allChannels.length > 0) {
            allChannels.forEach(function (channelOrGroup) {
                _this.emit("" + STATUS_PREFIX + channelOrGroup, data);
            });
        }
        else {
            this.emit(UNCLASSIFIED_EVENTS, data);
        }
    };
    return Listener;
}(events_1.EventEmitter));
var listener = new Listener();
var pubnub;
function isSubscribed(channelName) {
    if (pubnub) {
        if (channelName) {
            return listener.eventNames().indexOf(channelName) !== -1;
        }
        return true;
    }
    return false;
}
exports.isSubscribed = isSubscribed;
function subscribe(config) {
    if (pubnub) {
        throw new errors_1.KinveyError('You are already subscribed to the live service. Please unsubscribe before you subscribe again.');
    }
    var PubNub = config_1.getConfig(config_1.ConfigKey.PubNub);
    pubnub = new PubNub(Object.assign({}, { ssl: true, dedupeOnSubscribe: true }, config));
    pubnub.subscribe({ channelGroups: [config.userChannelGroup] });
    pubnub.addListener(listener);
}
exports.subscribe = subscribe;
function subscribeToChannel(channelName, receiver) {
    if (receiver === void 0) { receiver = {}; }
    var onMessage = receiver.onMessage, onError = receiver.onError, onStatus = receiver.onStatus;
    if (!isValidChannelName(channelName)) {
        throw new Error('Invalid channel name.');
    }
    if (!isValidReceiver(receiver)) {
        throw new Error('Invalid receiver.');
    }
    if (isFunction_1.default(onMessage)) {
        listener.on(channelName, onMessage);
    }
    if (isFunction_1.default(onError)) {
        listener.on("" + STATUS_PREFIX + channelName, function (status) {
            if (status.error) {
                onError(status);
            }
        });
    }
    if (isFunction_1.default(onStatus)) {
        listener.on("" + STATUS_PREFIX + channelName, function (status) {
            if (!status.error) {
                onStatus(status);
            }
        });
    }
    return true;
}
exports.subscribeToChannel = subscribeToChannel;
function unsubscribeFromChannel(channelName) {
    listener.removeAllListeners(channelName);
    listener.removeAllListeners("" + STATUS_PREFIX + channelName);
    return true;
}
exports.unsubscribeFromChannel = unsubscribeFromChannel;
function unsubscribe() {
    unsubscribeFromChannel();
    if (pubnub) {
        pubnub.removeListener(listener);
        pubnub.destroy();
        pubnub = null;
    }
    return true;
}
exports.unsubscribe = unsubscribe;
function reconnect() {
    if (pubnub) {
        pubnub.reconnect();
    }
}
exports.reconnect = reconnect;
//# sourceMappingURL=live.js.map